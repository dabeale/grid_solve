
#ifndef _GS_ANALYTIC_MULTIPLY_
#define _GS_ANALYTIC_MULTIPLY_

#include "algorithm/fmm.hpp"
#include "functions/exp_squared.hpp"

namespace gs {
template<int N, typename T, int D, typename S=uint32_t> 
/**
 * \brief A vector field.
 * 
 * The vector field provides the set of default template values for the 
 * fmm algorithm.
 * 
 * The template parameters,
 *      N           - The number of dimensions of the underlying grid.
 *      T           - The unit type (e.g. double)
 *      D           - The approximation degree.
 */
class vector_field {
public:
    using grid_val = std::tuple<T, T, vector<T, N>, int32_t>;
    using box_val = std::tuple<polynomial<T, N, D>, vector<T, N>, bool>;
    using f_box_weight = std::function<void(const box_stack<N>&, grid<N, grid_val, box_val>&)>;
    using f_traversal = std::function<void(const box_stack<N>&, grid<N, grid_val, box_val>&)>;
};

template<typename T, size_t M, size_t D, template < typename, size_t, size_t > class FuncEstimator>
requires (
    (M > 0) && (D > 0) &&
    requires(FuncEstimator<T, M, D> t) {
        { t(vector<T, M>(), vector<T, M>()) } -> std::same_as<T>;
        { t.estimate(polynomial<T, M, D>(), vector<T, M>(), vector<T, M>()) } -> std::same_as<T>;
        { 
            t.compute_coefs(std::array<vector<T, M>, 1>(), vector<T, M>(), std::array<T, 1>()) 
        } -> std::constructible_from<polynomial<T, M, D>>;
    }
)
/**
 * \brief An approximation of matrix multiplication, when the
 * matrix is generated by an analytic function.
 */
class analytic_multiply  {
    static constexpr size_t m_nBoxCorners = pow<2,M>(); ///< The number of corners of each box.

    using f_traversal = vector_field<M, T, D>::f_traversal; ///< The traversal function
    using f_box_weight = vector_field<M, T, D>::f_box_weight; ///< The box weight function
    using grid_val = gs::vector_field<M,T,D>::grid_val; ///< A value in the grid
    using box_val = gs::vector_field<M,T,D>::box_val;   ///< A value stored in each box
    using box_corners = std::array<vector<T,M>, m_nBoxCorners>; ///< The corners of the box
    using box_values = std::array<T, m_nBoxCorners>;      ///< The values at each corner

    /**
     * \brief Get the values and points at the corners of 
     * the input box.
     */
    static std::pair<box_corners, box_values> corner_vals(
        const gs::box<M>& boxImp,
        const gs::grid<M, grid_val, box_val>& grid
    ) {
        std::pair<box_corners, box_values> ret;
        for(size_t i=0; i<analytic_multiply::m_nBoxCorners; ++i){
            ret.first[i] = std::get<2>(grid[boxImp[i]]);
            ret.second[i] = std::get<1>(grid[boxImp[i]]);
        }
        return ret;
    };

    dimensions<M> m_dimensions; ///< The dimensions.
    FuncEstimator<T,M,D> m_f_estimator; ///< The analytic function estimator.
    fmm<M, uint32_t, f_traversal, f_box_weight, grid_val, box_val> m_fmm; ///< The FMM method.

public:
    analytic_multiply(const dimensions<M> dims, FuncEstimator<T,M,D> f_estimator):
        m_dimensions(dims),
        m_f_estimator(f_estimator),
        m_fmm(
            dims,
            [&](const box_stack<M>& boxStack, grid<M, grid_val, box_val>& grid){
                const auto finestBox = boxStack[boxStack.size()-1];

                for(size_t boxi = 0; boxi < boxStack.size(); ++boxi ){
                    // Find the index of the current box
                    const auto currentBoxi = boxStack[boxi].index_in_parent();
                    // For each of the neighbours at every level
                    for(size_t i=0; i<boxStack[boxi].n_nbrs(); ++i){
                        // Only approximate neighbour boxes
                        if(currentBoxi != i){
                            auto neighbour = boxStack[boxi].neighbour(i);
                            auto& nbrStorage = grid[neighbour];
                            // For each of the finest corners
                            for (size_t corneri = 0; corneri < m_nBoxCorners; ++corneri){
                                const auto corner = finestBox[corneri];
                                auto& cornerVec = grid[corner];
                                std::get<0>(cornerVec) += m_f_estimator.estimate(
                                    std::get<0>(nbrStorage), // The polynomial
                                    std::get<1>(nbrStorage), // The center of the box
                                    std::get<2>(cornerVec)   // The corner point
                                );
                            }
                        }
                    }
                }
                // Compute the precise value for the near field by multiplying 
                // and summing over all values.
                for( const auto& ci : finestBox){
                    for( const auto& cj : finestBox){
                        std::get<0>(grid[ci]) += (
                            m_f_estimator(std::get<2>(grid[ci]), std::get<2>(grid[cj]))*
                            std::get<1>(grid[cj])
                        );
                    }
                }
            },
            [&](const box_stack<M>& boxStack, grid<M, grid_val, box_val>& grid){
                for(const auto& box : boxStack ){
                    auto& boxVal = grid[box];
                    bool& firstIteration = std::get<2>(boxVal);
                    // Find the corners and values
                    const auto cornerVals = analytic_multiply::corner_vals(box, grid);
                    if(firstIteration){
                        // Compute the center of the box
                        std::get<1>(boxVal) = mean(cornerVals.first);
                        firstIteration = false;
                    }
                    // Update the polynomials.
                    std::get<0>(boxVal) += m_f_estimator.compute_coefs(
                        cornerVals.first,
                        std::get<1>(boxVal),
                        cornerVals.second
                    );
                }
            }
        ) {}

    /**
     * \brief Initialise the grid with the input values
     */
    void initialise(const std::vector<T>& init_vec){
        if(m_fmm.grid_size() != init_vec.size()){
            throw std::range_error("Incorrect size");
        }
        // Initialise the grid
        for (size_t i=0; i<m_fmm.grid_size(); ++i){
            m_fmm[i] = std::tuple<double, double, gs::vector<double, M>, int32_t>{
                0.0, // Output value
                init_vec[i], // Input Value
                gs::vector<double, M>(
                    m_dimensions.ind2sub(i, m_dimensions.max_level())
                ), // Position
                -1,  // Level computed at
            };
        }
    }

    /**
     * \brief Compute the solution
     */
    void compute() {
        m_fmm.compute();
    }

    /**
     * \brief Return the output
     */
    std::vector<T> output() const{
        const size_t size = m_fmm.grid_size();
        std::vector<T> out;
        out.reserve(size);
        for (size_t i=0; i<size; ++i){
            out.push_back(std::get<0>(m_fmm[i]));
        }
        return out;
    }
};
}

#endif