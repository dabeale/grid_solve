
#ifndef _GS_ANALYTIC_MULTIPLY_
#define _GS_ANALYTIC_MULTIPLY_

#include "algorithm/fmm.hpp"
#include "functions/exp_squared.hpp"

namespace gs {
template<int N, typename T, int D, typename S=uint32_t> 
/**
 * \brief A vector field.
 * 
 * The vector field provides the set of default template values for the 
 * fmm algorithm.
 * 
 * The template parameters,
 *      N           - The number of dimensions of the underlying grid.
 *      T           - The unit type (e.g. double)
 *      D           - The approximation degree.
 */
class vector_field {
public:
    using grid_val = std::tuple<T, T, vector<T, N>, int32_t>;
    using box_val = std::tuple<polynomial<T, N, D>, vector<T, N>, bool>;
    using f_box_weight = std::function<void(const box_stack<N>&, grid<N, grid_val, box_val>&)>;
    using f_traversal = std::function<void(const box_stack<N>&, grid<N, grid_val, box_val>&)>;
};

template<typename T, size_t M, size_t D, template < typename, size_t, size_t > class FuncEstimator>
requires (
    (M > 0) && (D > 0) &&
    requires(FuncEstimator<T, M, D> t) {
        { t(vector<T, M>(), vector<T, M>()) } -> std::same_as<T>;
        { t.estimate(polynomial<T, M, D>(), vector<T, M>(), vector<T, M>()) } -> std::same_as<T>;
        { 
            t.compute_coefs(std::array<vector<T, M>, 1>(), vector<T, M>(), std::array<T, 1>()) 
        } -> std::constructible_from<polynomial<T, M, D>>;
    } &&
    std::is_floating_point<T>::value
)
/**
 * \brief An approximation of matrix multiplication, when the
 * matrix is generated by an analytic function.
 */
class analytic_multiply  {
    static constexpr size_t m_nBoxCorners = pow<2,M>(); ///< The number of corners of each box.
    static constexpr double m_dTaylorTol = 0.1; ///< The tolerance below which we use Taylor expansions.

    using f_traversal = vector_field<M, T, D>::f_traversal; ///< The traversal function
    using f_box_weight = vector_field<M, T, D>::f_box_weight; ///< The box weight function
    using grid_val = gs::vector_field<M,T,D>::grid_val; ///< A value in the grid
    using box_val = gs::vector_field<M,T,D>::box_val;   ///< A value stored in each box
    using box_corners = std::array<vector<T,M>, m_nBoxCorners>; ///< The corners of the box
    using box_values = std::array<T, m_nBoxCorners>;      ///< The values at each corner

    /**
     * \brief Get the values and points at the corners of 
     * the input box.
     */
    static std::pair<box_corners, box_values> corner_vals(
        const gs::box<M>& boxImp,
        const gs::grid<M, grid_val, box_val>& grid
    ) {
        std::pair<box_corners, box_values> ret;
        for(size_t i=0; i<analytic_multiply::m_nBoxCorners; ++i){
            ret.first[i] = std::get<2>(grid[boxImp[i]]);
            ret.second[i] = std::get<1>(grid[boxImp[i]]);
        }
        return ret;
    };

    dimensions<M> m_dimensions; ///< The dimensions.
    FuncEstimator<T,M,D> m_f_estimator; ///< The analytic function estimator.
    fmm<M, uint32_t, f_traversal, f_box_weight, grid_val, box_val> m_fmm; ///< The FMM method.

public:
    analytic_multiply(const dimensions<M> dims, FuncEstimator<T,M,D> f_estimator):
        m_dimensions(dims),
        m_f_estimator(f_estimator),
        m_fmm(
            dims,
            [&](const box_stack<M>& boxStack, grid<M, grid_val, box_val>& grid){
                const auto finestBox = boxStack[boxStack.size()-1];
                for( const auto& ci : finestBox){
                    auto& corner_i = grid[ci];
                    // Only compute each point location once.
                    if ( !std::get<3>(corner_i) ){
                        // Iterate all boxes and find their neighbours
                        for(size_t boxi = 1; boxi < boxStack.size()-1; ++boxi ){
                            // Find the index of the current box
                            const auto currentBoxi = boxStack[boxi].index_in_parent();
                            // For each of the neighbours at every level
                            for(size_t i=0; i<boxStack[boxi].n_nbrs(); ++i){
                                // Only approximate neighbour boxes
                                if(currentBoxi != i){
                                    auto neighbour = boxStack[boxi].neighbour(i);
                                    auto& nbrStorage = grid[neighbour];
                                    auto est =  m_f_estimator.estimate(
                                        std::get<0>(nbrStorage), // The polynomial
                                        std::get<1>(nbrStorage), // The center of the box
                                        std::get<2>(corner_i)    // The corner point
                                    );
                                    if (neighbour.is_inside(ci)){
                                        m_f_estimator.estimate(
                                            std::get<0>(nbrStorage), // The polynomial
                                            std::get<1>(nbrStorage), // The center of the box
                                            std::get<2>(corner_i)    // The corner point
                                        );
                                    }
                                    std::get<0>(corner_i) += est;
                                }
                            }
                        }
                        // Compute the precise value for the near field by multiplying 
                        // and summing over all values.
                        for( const auto& cj : finestBox){
                            const auto& corner_j = grid[cj];
                            std::get<0>(corner_i) += (
                                m_f_estimator(std::get<2>(corner_i), std::get<2>(corner_j))*
                                std::get<1>(corner_j)
                            );
                        }
                        // Mark the corner as done
                        std::get<3>(corner_i) = 1;
                    }
                }
            },
            [&](const box_stack<M>& boxStack, grid<M, grid_val, box_val>& grid){
                // Compute the center for every box
                for(const auto& box : boxStack ){
                    auto& boxVal = grid[box];
                    bool& doneFirst = std::get<2>(boxVal);
                    const auto cornerVals = analytic_multiply::corner_vals(box, grid);
                    if(!doneFirst){
                        // Compute the center of the box
                        std::get<1>(boxVal) = mean(cornerVals.first);
                        doneFirst = true;
                    }
                }
                // Update every box with the parameters of the leaf nodes
                const auto& leafBox = boxStack[boxStack.size()-1];
                // Find the corners and values
                const auto cornerVals = analytic_multiply::corner_vals(leafBox, grid);
                for(size_t boxi = 1; boxi < boxStack.size()-1; ++boxi  ){
                    auto& boxVal = grid[boxStack[boxi]];
                    const auto& leafCenter = std::get<1>(grid[leafBox]);
                    const auto& boxCenter = std::get<1>(boxVal);
                    // Taylor is only accurate for nearby points.
                    if(m_f_estimator(leafCenter, boxCenter) > m_dTaylorTol){
                        // Update the polynomials.
                        std::get<0>(boxVal) += m_f_estimator.compute_coefs(
                            cornerVals.first,
                            std::get<1>(boxVal),
                            cornerVals.second
                        );
                    }
                }
            }
        ) {}

    /**
     * \brief Initialise the grid with the input values
     */
    void initialise(const std::vector<T>& init_vec){
        if(m_fmm.grid_size() != init_vec.size()){
            throw std::range_error("Incorrect size");
        }
        // Initialise the grid
        for (size_t i=0; i<m_fmm.grid_size(); ++i){
            m_fmm[i] = std::tuple<double, double, gs::vector<double, M>, int32_t>{
                0.0, // Output value
                init_vec[i], // Input Value
                gs::vector<double, M>(
                    m_dimensions.ind2sub(i, m_dimensions.max_level()-1)
                ), // Position
                0,  // Level computed at
            };
        }
    }

    /**
     * \brief Compute the solution
     */
    void compute() {
        m_fmm.compute();
    }

    /**
     * \brief Return the output
     */
    std::vector<T> output() const{
        const size_t size = m_fmm.grid_size();
        std::vector<T> out;
        out.reserve(size);
        for (size_t i=0; i<size; ++i){
            out.push_back(std::get<0>(m_fmm[i]));
        }
        return out;
    }
};
}

#endif