// Copyright 2024 Daniel Beale CC BY-NC-SA 4.0
#ifndef LIB_IMPLEMENTATION_ANALYTIC_MULTIPLY_HPP_
#define LIB_IMPLEMENTATION_ANALYTIC_MULTIPLY_HPP_

#include <utility>
#include <tuple>
#include <vector>

#include "algorithm/fmm.hpp"
#include "estimators/estimator.hpp"
#include "functions/exp_squared.hpp"

namespace gs {
template<typename T, size_t M, size_t D, template < typename, size_t, size_t > class FuncEstimator>
requires(
    (M > 0) && (D > 0) && estimator<T, M, D, FuncEstimator> &&
    std::is_floating_point<T>::value
)
/**
 * \brief An approximation of matrix multiplication, when the
 * matrix is generated by an analytic function.
 */
class analytic_multiply  {
 public:
     /**
     * \brief A value set at each point in the grid.
     * 
     * The grid value contains the x and y input values, and 
     * the output value. 
     */
    struct grid_val {
        T m_targetValue;  ///< The y value that will be computed (output)
        T m_inputValue;  ///< The y input value.
        gs::vector<T, M> m_xVal;   ///< The input x value.

     public:
        grid_val() : m_targetValue(0), m_inputValue(0) {}
        grid_val(const T targetVal, const T inputVal, const gs::vector<T, M>& xVal) :
            m_targetValue(targetVal), m_inputValue(inputVal), m_xVal(xVal) {}
    };

    /**
     * \brief A value storage for each box in the grid.
     * 
     * The box storage is for storing values which are used to
     * compute the result.
     */
    struct box_val {
        polynomial<T, M, D> m_polyEstimator;  ///< The polynomial for approximating multiplication.
        gs::vector<T, M> m_center;  ///< The center of the box.
        bool m_centerComputed;   ///< True if the center has been computed
        size_t m_boxUsedIndex;   ///< The index that the box has been computed at.

     public:
        box_val() : m_centerComputed(0), m_boxUsedIndex(0) {}
    };

    using f_box_weight = std::function< void(const box_stack<M>&, grid<M, grid_val, box_val>&)>;  ///< The box weight functor
    using f_traversal = std::function< void(const base_box<M>&, grid<M, grid_val, box_val>&)>;  ///< The traversal functor

 private:
    static constexpr size_t m_nBoxCorners = pow<2, M>();  ///< The number of corners of each box.

    using box_corners = typename std::array< gs::vector<T, M>, m_nBoxCorners>;  ///< The corners of the box
    using box_values = typename std::array<T, m_nBoxCorners>;  ///< The values at each corner

    /**
     * \brief Get the values and points at the corners of 
     * the input box.
     */
    static std::pair<box_corners, box_values> corner_vals(
        const gs::box<M>& boxImp,
        const gs::grid<M, grid_val, box_val>& grid
    ) {
        std::pair<box_corners, box_values> ret;
        for ( size_t i = 0; i < analytic_multiply::m_nBoxCorners; ++i ) {
            ret.first[i] = grid[boxImp[i]].m_xVal;
            ret.second[i] = grid[boxImp[i]].m_inputValue;
        }
        return ret;
    }

    dimensions<M> m_dimensions;  ///< The dimensions.
    FuncEstimator<T, M, D> m_f_estimator;  ///< The analytic function estimator.
    fmm<M, uint32_t, f_traversal, f_box_weight, grid_val,  box_val> m_fmm;  ///< The FMM method.

 public:
    analytic_multiply(const dimensions<M> dims, FuncEstimator<T, M, D> f_estimator):
        m_dimensions(dims),
        m_f_estimator(f_estimator),
        m_fmm(
            dims,
            [&](
                const base_box<M>& baseBox,
                grid<M, grid_val, box_val>& grid
            ) {
                std::array<box<M>, base_box<M>::m_nCorners> principalBoxes;
                // Add the boxes on the corners of the duel box.
                for ( size_t i = 0; i < base_box<M>::m_nCorners; ++i) {
                    principalBoxes[i] = box<M>(
                        m_dimensions,
                        baseBox[i],
                        dimensions<M>::BOXES_SUBDIVISION
                    );
                }

                // A unique index for the box
                const size_t currentIndex = m_dimensions.sub2ind(
                    baseBox[0].at_level(
                        m_dimensions.max_level()-1,
                        dimensions<M>::BOXES_SUBDIVISION
                    ),
                    m_dimensions.max_level()-1,
                    dimensions<M>::BOXES_SUBDIVISION,
                    dimensions<M>::POINTS_MODE
                );

                // Add the contributions of all principal boxes.
                for ( const auto& cornerB : baseBox ) {
                    auto& cornerBI = grid[cornerB];
                    for ( const auto& principalBox : principalBoxes ) {
                        grid[principalBox].m_boxUsedIndex = currentIndex;
                        for ( const auto& cornerA : principalBox ) {
                                const auto& cornerAI = grid[cornerA];
                                cornerBI.m_targetValue += (
                                    m_f_estimator(
                                        cornerAI.m_xVal,
                                        cornerBI.m_xVal
                                    )*cornerAI.m_inputValue
                                );
                        }
                    }
                }

                // Ensure that non of the stack boxes are used for approximations
                for ( const auto& principalBox : principalBoxes ) {
                    box<M> stackBox(principalBox);
                    for ( size_t lvl = 1; lvl < m_dimensions.max_level(); ++lvl) {
                        grid[stackBox].m_boxUsedIndex = currentIndex;
                        stackBox = stackBox.parent();
                    }
                }

                // Iterate all secondary boxes and add contributions
                for ( auto principalBox : principalBoxes ) {
                    // For each of the duel boxes
                    box<M> stackBox(principalBox);
                    for ( size_t lvl = 1; lvl < m_dimensions.max_level(); ++lvl) {
                        // Go up the box stack
                        for ( size_t i=0; i < base_box<M>::m_nCorners; ++i ) {
                            // For each neighbour box (not in the stack)
                            const auto nbrBox = stackBox.neighbour(i);
                            if ( nbrBox.index_in_parent() != stackBox.index_in_parent() ) {
                                auto& nbrStorage = grid[nbrBox];
                                // If the contribution has not already bee added.
                                if ( nbrStorage.m_boxUsedIndex != currentIndex ) {
                                    // For each of the target points (in the base box)
                                    for ( const auto& corner : baseBox ) {
                                        // Add the contributions.
                                        auto& cornerI = grid[corner];
                                        cornerI.m_targetValue += m_f_estimator.estimate(
                                            nbrStorage.m_polyEstimator,  // polynomial
                                            nbrStorage.m_center,  // center
                                            cornerI.m_xVal  // corner point
                                        );
                                    }
                                    nbrStorage.m_boxUsedIndex = currentIndex;
                                }
                            }
                        }
                        stackBox = stackBox.parent();
                    }
                }
            },
            [&](
                const box_stack<M>& boxStack,
                grid<M, grid_val, box_val>& grid
            ) {
                // Compute the center for every box
                for ( const auto& box : boxStack ) {
                    auto& boxVal = grid[box];
                    if ( !boxVal.m_centerComputed ) {
                        // Compute the center of the box
                        const auto cornerVals = analytic_multiply::corner_vals(box, grid);
                        boxVal.m_center = mean(cornerVals.first);
                        boxVal.m_centerComputed = true;
                    }
                }
                // Update every box with the parameters of the leaf nodes
                const auto& leafBox = boxStack[boxStack.size()-1];
                // Find the corners and values
                const auto cornerVals = analytic_multiply::corner_vals(leafBox, grid);
                for ( size_t boxi = 1; boxi < boxStack.size(); ++boxi ) {
                    auto& boxVal = grid[boxStack[boxi]];
                    // Update the polynomials.
                    boxVal.m_polyEstimator += m_f_estimator.compute_coefs(
                        cornerVals.first,
                        boxVal.m_center,
                        cornerVals.second
                    );
                }
            },
            dimensions<M>::BOXES_SUBDIVISION
        ) {}

    /**
     * \brief Initialise the grid with the input values
     */
    void initialise(const std::vector<T>& init_vec) {
        if ( m_fmm.grid_size() != init_vec.size() ) {
            throw std::range_error("Incorrect size");
        }
        // Initialise the grid
        for ( size_t i = 0; i < m_fmm.grid_size(); ++i ) {
            m_fmm[i] = grid_val(
                0.0,  // Output value
                init_vec[i],  // Input Value
                gs::vector<double, M>(
                    m_dimensions.ind2sub(
                        i, m_dimensions.max_level()-1, dimensions<M>::BOXES_SUBDIVISION
                    )
                )   // Position
            );
        }
    }

    /**
     * \brief Compute the solution
     */
    void compute() {m_fmm.compute();}

    /**
     * \brief Return the output
     */
    std::vector<T> output() const{
        const size_t size = m_fmm.grid_size();
        std::vector<T> out;
        out.reserve(size);
        for ( size_t i = 0; i < size; ++i ) {
            out.push_back(m_fmm[i].m_targetValue);
        }
        return out;
    }
};
}  // namespace gs

#endif  // LIB_IMPLEMENTATION_ANALYTIC_MULTIPLY_HPP_
