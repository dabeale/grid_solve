// Copyright 2024 Daniel Beale CC BY-NC-SA 4.0
#ifndef LIB_IMPLEMENTATION_ANALYTIC_MULTIPLY_HPP_
#define LIB_IMPLEMENTATION_ANALYTIC_MULTIPLY_HPP_

#include <utility>
#include <tuple>
#include <vector>

#include "algorithm/fmm.hpp"
#include "functions/exp_squared.hpp"

namespace gs {
template<int N, typename T, int D, typename S = uint32_t>
/**
 * \brief A vector field.
 * 
 * The vector field provides the set of default template values for the 
 * fmm algorithm.
 * 
 * The template parameters,
 *      N           - The number of dimensions of the underlying grid.
 *      T           - The unit type (e.g. double)
 *      D           - The approximation degree.
 */
class vector_field {
 public:
    using grid_val = std::tuple<T, T, gs::vector<T, N>, int32_t>;
    using box_val = std::tuple<polynomial<T, N, D>, gs::vector<T, N>, bool>;
    using f_box_weight = std::function< void(const box_stack<N>&, grid<N, grid_val, box_val>&)>;
    using f_traversal = std::function< void(const box_stack<N>&, grid<N, grid_val, box_val>&)>;
};

template<typename T, size_t M, size_t D, template < typename, size_t, size_t > class FuncEstimator>
requires(
    (M > 0) && (D > 0) &&
    requires(FuncEstimator<T, M, D> t) {
        {
            t(gs::vector<T, M>(), gs::vector<T, M>())
        } -> std::same_as<T>;
        {
            t.estimate(
                polynomial<T, M, D>(),
                gs::vector<T, M>(),
                gs::vector<T, M>())
        } -> std::same_as<T>;
        {
            t.compute_coefs(
                std::array<gs::vector<T, M>, 1>(),
                gs::vector<T, M>(),
                std::array<T, 1>())
        } -> std::constructible_from<polynomial<T, M, D>>;
    } &&
    std::is_floating_point<T>::value
)
/**
 * \brief An approximation of matrix multiplication, when the
 * matrix is generated by an analytic function.
 */
class analytic_multiply  {
    static constexpr size_t m_nBoxCorners = pow<2, M>();
        ///< The number of corners of each box.

    using f_traversal = typename vector_field<M, T, D>::f_traversal;  ///< The traversal function
    using f_box_weight = typename vector_field<M, T, D>::f_box_weight;  ///< The box weight function
    using grid_val = typename gs::vector_field<M, T, D>::grid_val;  ///< A value in the grid
    using box_val = typename gs::vector_field<M, T, D>::box_val;  ///< A value stored in each box
    using box_corners = typename std::array< gs::vector<T, M>, m_nBoxCorners>;  ///< The corners of the box
    using box_values = typename std::array<T, m_nBoxCorners>;  ///< The values at each corner

    /**
     * \brief Get the values and points at the corners of 
     * the input box.
     */
    static std::pair<box_corners, box_values> corner_vals(
        const gs::box<M>& boxImp,
        const gs::grid<M, grid_val, box_val>& grid
    ) {
        std::pair<box_corners, box_values> ret;
        for ( size_t i = 0; i < analytic_multiply::m_nBoxCorners; ++i ) {
            ret.first[i] = std::get<2>(grid[boxImp[i]]);
            ret.second[i] = std::get<1>(grid[boxImp[i]]);
        }
        return ret;
    }

    dimensions<M> m_dimensions;  ///< The dimensions.
    FuncEstimator<T, M, D> m_f_estimator;  ///< The analytic function estimator.
    fmm<M, uint32_t, f_traversal, f_box_weight, grid_val,  box_val> m_fmm;  ///< The FMM method.

 public:
    analytic_multiply(
        const dimensions<M> dims,
        FuncEstimator<T, M, D> f_estimator):
        m_dimensions(dims),
        m_f_estimator(f_estimator),
        m_fmm(
            dims,
            [&](
                const box_stack<M>& boxStack,
                grid<M, grid_val, box_val>& grid
            ) {
                const size_t cutoff = 1;
                const auto finestBox = boxStack[boxStack.size()-1];
                for ( const auto& ci : finestBox ) {
                    auto& corner_i = grid[ci];
                    // Iterate all boxes and find their neighbours
                    // The zeroth box has no neighbours.
                    for (
                        size_t boxi = 1;
                        boxi < boxStack.size()-cutoff;
                        ++boxi
                    ) {
                        // Find the index of the current box
                        const auto currentBoxi = boxStack[
                            boxi
                        ].index_in_parent();
                        // For each of the neighbours at every level
                        for ( size_t i = 0; i < boxStack[boxi].n_nbrs(); ++i ) {
                            // Only approximate neighbour boxes
                            if ( currentBoxi != i ) {
                                auto neighbour = boxStack[boxi-1].subbox(i);
                                auto& nbrStorage = grid[neighbour];
                                std::get<0>(corner_i) += m_f_estimator.estimate(
                                    std::get<0>(nbrStorage),  // polynomial
                                    std::get<1>(nbrStorage),  // center
                                    std::get<2>(corner_i)     // corner point
                                );
                            }
                        }
                    }
                    // Compute the precise value for the near field
                    // by multiplying and summing over all values.
                    for (
                        size_t boxi = boxStack.size()-cutoff;
                        boxi < boxStack.size();
                        ++boxi
                    ) {
                        for ( size_t i = 0; i < boxStack[boxi].n_nbrs(); ++i ) {
                            auto neighbour = boxStack[boxi-1].subbox(i);
                            for ( const auto& cj : neighbour ) {
                                const auto& corner_j = grid[cj];
                                std::get<0>(corner_i) += (
                                    m_f_estimator(
                                        std::get<2>(corner_i),
                                        std::get<2>(corner_j)
                                    )*std::get<1>(corner_j)
                                );
                            }
                        }
                    }
                }
            },
            [&](
                const box_stack<M>& boxStack,
                grid<M, grid_val, box_val>& grid
            ) {
                // Compute the center for every box
                for ( const auto& box : boxStack ) {
                    auto& boxVal = grid[box];
                    bool& doneFirst = std::get<2>(boxVal);
                    if ( !doneFirst ) {
                        // Compute the center of the box
                        const auto cornerVals = analytic_multiply::corner_vals(box, grid);
                        std::get<1>(boxVal) = mean(cornerVals.first);
                        doneFirst = true;
                    }
                }
                // Update every box with the parameters of the leaf nodes
                const auto& leafBox = boxStack[boxStack.size()-1];
                // Find the corners and values
                const auto cornerVals = analytic_multiply::corner_vals(
                    leafBox, grid);
                for ( size_t boxi = 1; boxi < boxStack.size(); ++boxi ) {
                    auto& boxVal = grid[boxStack[boxi]];
                    // Update the polynomials.
                    std::get<0>(boxVal) += m_f_estimator.compute_coefs(
                        cornerVals.first,
                        std::get<1>(boxVal),
                        cornerVals.second
                    );
                }
            },
            dimensions<M>::BOXES_SUBDIVISION
        ) {}

    /**
     * \brief Initialise the grid with the input values
     */
    void initialise(const std::vector<T>& init_vec) {
        if ( m_fmm.grid_size() != init_vec.size() ) {
            throw std::range_error("Incorrect size");
        }
        // Initialise the grid
        for ( size_t i = 0; i < m_fmm.grid_size(); ++i ) {
            m_fmm[i] = std::tuple<double, double, gs::vector<double, M>, int32_t> {
                0.0,  // Output value
                init_vec[i],  // Input Value
                gs::vector<double, M>(
                    m_dimensions.ind2sub(
                        i, m_dimensions.max_level()-1, dimensions<M>::BOXES_SUBDIVISION
                    )
                ),   // Position
                0,   // Level computed at
            };
        }
    }

    /**
     * \brief Compute the solution
     */
    void compute() {m_fmm.compute();}

    /**
     * \brief Return the output
     */
    std::vector<T> output() const{
        const size_t size = m_fmm.grid_size();
        std::vector<T> out;
        out.reserve(size);
        for ( size_t i = 0; i < size; ++i ) {
            out.push_back(std::get<0>(m_fmm[i]));
        }
        return out;
    }
};
}  // namespace gs

#endif  // LIB_IMPLEMENTATION_ANALYTIC_MULTIPLY_HPP_
