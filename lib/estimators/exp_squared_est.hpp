
#ifndef _GS_EXP_SQUARED_EST_
#define _GS_EXP_SQUARED_EST_

#include <cmath>

#include "functions/exp_squared.hpp"
#include "functions/exp_inner.hpp"
#include "math/taylor.hpp"
#include "math/polynomial.hpp"

namespace gs {
template<typename T, size_t M, size_t D>
/**
 * \brief An estimate of the exp_squared function.
 * 
 * The estimator produces an exact estimate of exp_squared given a
 * pair of inputs to the call operator, and can be used to approximate
 * vector dot product between an arbitrary vector and one generated
 * by exp_squared, against a particular point.
 */
class exp_squared_est  {
    exp_squared<T, M, 0> m_exp_squared;     ///< The exp_squared function
    exp_inner<T, M, D> m_exp_inner;         ///< The exp inner product estimate
    taylor<T, M, D, exp_inner> m_taylor;  ///< The taylor estimate

public:
    exp_squared_est(const T sigma):
        m_exp_squared(sigma),
        m_exp_inner(sigma),
        m_taylor(m_exp_inner) {}

    /**
     * \brief Compute the exact value using the estimator
     */
    T operator()(const vector<T, M>& a, const vector<T, M>& b) const{
        return m_exp_squared(a,b);
    }

    /**
     * \brief Estimate an approximation of the exp_squared function
     * using Taylor and a polynomial of coefficients.
     * 
     * The polynomial input is pre-computed and approximates a potentially
     * large vector, which is generated by exp_squared, about an appropriate
     * center. Given these two parameters and an arbitrary vector y, the 
     * approximate dot product is returned. The accuracy is determined by the
     * template parameter D, but should be small (~2) to remain sufficiently
     * efficient.
     */
    T estimate(
        const polynomial<T, M, D>& poly,
        const vector<T, M>& center,
        const vector<T,M>& y
    ) const{
        return m_taylor.estimate(poly, center, y);
    }

    template<size_t K>
    /**
     * \brief Compute the polynomial coefficients for estimation
     * using Taylor.
     * 
     * The estimation is an estimate of the sum over each of the input
     * vectors, multiplied by an arbitrary vector of values. It 
     * is essentially an estimate of the dot product of the vector generated
     * by the function and the values.
     */
    polynomial<T, M, D> compute_coefs(
        std::array<vector<T, M>, K> vectorVals,
        const vector<T, M>& center,
        std::array<T, K> tVals
    ) const {
        polynomial<T, M, D> poly;
        for(size_t i=0; i<K; ++i){
            vectorVals[i] -= center;
            tVals[i] *= operator()(vectorVals[i],center);
        }
        poly.fill(vectorVals, tVals);
        return poly;
    }
};
}

#endif